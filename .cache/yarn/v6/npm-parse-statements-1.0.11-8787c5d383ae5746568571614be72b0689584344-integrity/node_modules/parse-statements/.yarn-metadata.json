{
  "manifest": {
    "name": "parse-statements",
    "version": "1.0.11",
    "description": "Fast and easy parser of statements in source code in any language ✂️",
    "author": {
      "name": "uid11"
    },
    "bugs": {
      "url": "https://github.com/joomcode/parse-statements/issues"
    },
    "devDependencies": {
      "prettier": ">=3.4",
      "typescript": ">=5.7"
    },
    "exports": {
      ".": {
        "import": "./index.js",
        "require": "./index.cjs",
        "types": "./index.d.ts"
      }
    },
    "files": [
      "getPreparedOptions.cjs",
      "getPreparedOptions.js",
      "index.cjs",
      "index.js",
      "index.d.ts",
      "types.d.ts"
    ],
    "homepage": "https://github.com/joomcode/parse-statements#readme",
    "keywords": [
      "parse",
      "parser",
      "source",
      "statement"
    ],
    "license": "MIT",
    "packageManager": "npm@10",
    "repository": {
      "type": "git",
      "url": "git+https://github.com/joomcode/parse-statements.git"
    },
    "scripts": {
      "prettier": "prettier --cache --cache-strategy=content --write .",
      "prebuild": "rm -f *.cjs *.js *.d.ts",
      "build": "tsc",
      "postbuild": "node ./convertEsmToCjs.js",
      "test": "export _START=$(date +%s%3N) && npm run prettier && npm run build && node ./index.spec.js",
      "prepublishOnly": "npm test"
    },
    "sideEffects": false,
    "type": "module",
    "types": "./index.d.ts",
    "_registry": "npm",
    "_loc": "/home/astor/neovim/.cache/yarn/v6/npm-parse-statements-1.0.11-8787c5d383ae5746568571614be72b0689584344-integrity/node_modules/parse-statements/package.json",
    "readmeFilename": "README.md",
    "readme": "# parse-statements ✂️\n\n[![NPM version][npm-image]][npm-url]\n[![dependencies: none][dependencies-none-image]][dependencies-none-url]\n[![minzipped size][size-image]][size-url]\n[![code style: prettier][prettier-image]][prettier-url]\n[![Conventional Commits][conventional-commits-image]][conventional-commits-url]\n[![License MIT][license-image]][license-url]\n\nFast and easy parser of statements in source code in any language.\n\n`parse-statements` ✂️ allows you to parse statements consisting of a sequence of tokens\nwith arbitrary text between them. Statements cannot overlap.\n\nIn addition to statements, language comments can be described, which can also be located\ninside statements (between its neighboring tokens).\n\nStrings are used to describe (find) tokens, from which regexps with `gmu` flags are generated\n(therefore, the backslash in these lines must be escaped, that is, it must be doubled).\n\nFor each parsed statement, the optional `onParse` callback is called with the context,\nsource code (string), and an array of tokens of statement\n(and an array of comments between this token and the next one, if any).\n\nIf the sequence of tokens of statement has not completed, instead of the `onParse` callback,\nan `onError` callback with the same signature is called, receiving an incomplete sequence\nof parsed tokens of statement.\n\nSimilar optional callbacks can be set for comments.\n\nCallbacks for statements (only for statements, not for comments) can return a number\ninstead of an `undefined` — then this number will be used as an index at the source code,\nstarting from which the parser will find the next statement.\n\nIn fact, this index will be interpreted as the end of the statement. By default,\nthe end of the statement coincides with the end of its last token,\nbut sometimes we may need to go beyond the boundaries of the found tokens\n(or, conversely, reduce the length of the statement, that is, reduce its end index).\n\nWith such manual parsing, if we increase the index of the end of the statement,\nwe must remember to manually parse the comments that may appear\nin this part of the statement — because the parser itself will not do this.\nIt will continue to work from the new end of the statement as usual.\n\n## Basic example\n\nBelow is a simplified example ([see on TypeScript Playground](https://www.typescriptlang.org/play?#code/JYWwDg9gTgLgBAbwMZQKYEMaoArqgZ1QDEBXAOyRmAjIF84AzKCEOAcjD0IFp8ZNUIVGRj42AbgBQk0JFhwYATzCpEAeTIBhFkJEBRKMygAaOBu0hdMXAVSmNNwvSYt2nW735YrYqZKQ0fAoAFswA7gZGcAC8cAAUQvj46ADmqABccHxQwGQpAJSZAG4QwAAmMQB8iJJwIeFwZKhhcJHQCahJqaj5UrR+Sipw2iKoAB7wsQBKGGU0ADaKADwItXCohtD4meQA1mQQYWQA2gC6UnXjcqKZx1fQN1kwOXmmAHQfAZbCj9m5KWdTmcLnBZA9tnBjmDYJk-q84B83l8fLDnv9AcC1iASPMqPNcqgLCini8Aec1vh-vNUPimkSfhC4WS+pU-AEyEE0jB6SIAMoQEhQJCqWJxCkCoUZEn-YxrTjAKCZNDoOZkRaQhDCMqZMgkEAAIw2tFMCD4eBgOr1hqgtFOssK0ryVSyEuFb3w+OFcXlUGOAAZTm8taYfccAIyBs2wXrSdlBGg8mBtRVmLQ6H7JpYjLATaqigD67JzMFM+FddkQUZgtHyztWdRgoUOybiZcFbo9wC9VfyMf6scC8AT6ZEjil5hH1i4qCzNGLefipqpNIJifwxpd7YrmrIZQ3pv4sBrdYpy9phMn+DeYBI+GCrfL7s9qDiwae5t7fTZg7gNGTmQcadZ1GXMYkXDYjHXUty3eD4YAgXZhHwWtomqet1k2Ahr1ve820lJ8uxfeDEI5f1TgAQndQ8SwUBCkOOYikLeak8kbOBuDgCNKK1OAAGo4AAZj9T9JH7fwfz-MZrjHACyDHYDi1MASFzFOpNSk8FjXFLdZUuDTYF5ajdPWfSYAAGWAPg9F3Yz7lgayyntE86jjeA7JgQzzTXMD3M82AkUvAB+N4QHQMA4m9dAFRQ6ouUTfktwfHS4B9ESXJ-dyLL4bzYkyyyk13ALvhEfBgtC8LIui504snBLJSSyUQyiqARLWdyrxvO84mONY6jwjtn1fUy-JgIMbJM64HKoj9jLqREhuuEbvIAH2WyFTnyWaEQ+BaHiy7lLzgVb1s2tYNq-AcOSHMgAElwAeGTU3k7Nxho5SwNUxBoVELS+pgtZvpG4zvqIZgQGB+77JsyQYpqdKrtBSGPOonLEcW6iip8Mqwoi1LqtQA7io88sGuFJropjeGghBsHUZplhMYZbGKrx1C4Bqom6u7GCUua1q6m+jqcO63rN3wzsvUBjG32+qaey2+apa8w7jrOU66jmnb6ZAFa1rV4zztE78EfcQg7uufA9FM-AwJQDAsDHUgKCoGgFNeyo4nQ5EGVuUX0I138yH-QPE2TLa6hoR7hyJsdw9okiIWONgAB1k4AelTtO2FMNgABJU7IQK2DtUXfo1-2Nb-TDMmjqww9FiO5OnTJPexXFgHPNcN367ctX3KtjzZiuA7bvFV0vbCup7givTfHtKYDuAy4DxiOVuFP09TgAqbP2G3zPi62suS8b4O4kLOdXtMfMe9MRJkjSWHG3CFt7+6dX328H3IT9hu4CQdAt0KDzBIGUC8RMITPBIHYP+VcjBx0js3QO5sHrTjgOgG2gFbBx1XonNgAA9b6qd9S7w3vqFwIBiGkPzsnQuh8-53gFPMMovIMBCmCAAIVQAwaA4DiRQJgQHZecNF4AKAUgEBYC1yZAEQgoOmE5FRyDqZMc6DMFN2wX-XB698HuSoTnVOtBqEFyLifRejCcQsLYUgTh3DeHSIUFAaBR8DayhrMbamSNLbW0yC9CYYF0IQS2LcMx7UQkQwtuErEOIx50kvFEvqZ5x4QKiWJU2qAUGwG8RbT6gsrYW2MgAAxkEjRAPCIDODBuwN4adykSBKdcOA+o8CMCqWwGpzSoBsGkGnNOcAAAqwRLKghtugf+k5pDfTgGnLeLohDjKJnALefTOmtNcJ0vwbB0DzDLGjB4azWAbO6Q0-ZqyKHVLTs0gAXscqZYRgBsSCVAKQUzekLKsKCMgez5D3MbAKeAFC-DuTKRACp0zZnbN2d7EQ9BllSGBTM95PxPkTQeLCvpCBOm0EkIU+0HiIDUmYhAFIcQ8nWxjEAA))\nof parsing `import` and `export` statements in ECMAScript\n(a complete example can be found [here](https://github.com/joomcode/parse-imports-exports/blob/main/src/index.ts)):\n\n```ts\nimport {createParseFunction} from 'parse-statements';\n\nimport type {OnCommentError, OnCommentParse, OnParse} from 'parse-statements';\n\nconst throwError = (message: string): void => {\n  throw new Error(message);\n};\n\ntype Context = Readonly<{\n  errors: unknown[];\n  exports: [exports: string, ...comments: string[]][];\n  imports: [import: string, ...comments: string[]][];\n  multilineComments: string[];\n  singlelineComments: string[];\n}>;\n\nconst getCommentSource = (\n  source: string,\n  pair: readonly [{end: number}, {start: number}],\n): string => source.slice(pair[0].end, pair[1].start);\n\nconst onCommentError: OnCommentError<Context> = (_context, source, {start}) => {\n  throwError(source.slice(start));\n};\n\nconst onCommentParse: OnCommentParse<Context> = ({singlelineComments}, source, {end}, {start}) => {\n  singlelineComments.push(source.slice(end, start));\n};\n\nconst onError: OnParse<Context> = ({errors}, source, ...tokens) => {\n  errors.push(source.slice(tokens[0]!.start, tokens[tokens.length - 1]!.end + 30));\n};\n\nconst onExportParse: OnParse<Context, 3> = (\n  {exports},\n  source,\n  exportStart,\n  exportListEnd,\n  exportEnd,\n) => {\n  const exportStartComments = exportStart.comments?.map((pair) => getCommentSource(source, pair));\n  const exportListComments = exportListEnd.comments?.map((pair) => getCommentSource(source, pair));\n\n  exports.push([\n    source.slice(exportStart.end, exportEnd.start),\n    ...(exportStartComments || []),\n    ...(exportListComments || []),\n  ]);\n};\n\nconst onImportParse: OnParse<Context, 3> = (\n  {imports},\n  source,\n  importStart,\n  importFrom,\n  importEnd,\n) => {\n  const importStartComments = importStart.comments?.map((pair) => getCommentSource(source, pair));\n  const importFromComments = importFrom.comments?.map((pair) => getCommentSource(source, pair));\n\n  imports.push([\n    source.slice(importStart.end, importEnd.start),\n    ...(importStartComments || []),\n    ...(importFromComments || []),\n  ]);\n};\n\nconst parseImportsExports = createParseFunction<Context>({\n  comments: [\n    {\n      onError: onCommentError,\n      onParse: onCommentParse,\n      tokens: ['\\\\/\\\\/', '$\\\\n?'],\n    },\n    {\n      onError: onCommentError,\n      onParse: ({multilineComments}, source, {end}, {start}) => {\n        multilineComments.push(source.slice(end, start));\n      },\n      tokens: ['\\\\/\\\\*', '\\\\*\\\\/'],\n    },\n  ],\n  onError: (_context, _source, message) => throwError(message),\n  statements: [\n    {\n      canIncludeComments: true,\n      onError,\n      onParse: onImportParse as OnParse,\n      tokens: ['^import\\\\b', '\\\\bfrom\\\\b', '$\\\\n?'],\n      shouldSearchBeforeComments: true,\n    },\n    {\n      canIncludeComments: true,\n      onError,\n      onParse: onExportParse as OnParse,\n      tokens: ['^export\\\\b', '\\\\}', '$\\\\n?'],\n      shouldSearchBeforeComments: true,\n    },\n  ],\n});\n\nconst importsExports: Context = {\n  errors: [],\n  exports: [],\n  imports: [],\n  multilineComments: [],\n  singlelineComments: [],\n};\n\nparseImportsExports(\n  importsExports,\n  `\nimport {foo} from './foo';\nimport bar from './bar'\n\n// This is a comment\n\nimport /* some comment */ bar from bar;\n\n'also import from bar;'\n\nimport bar from './baz'\n\nimport with error;\nimport // comment in import without from;\n\nexport {foo} /* also comment} */;\nexport /* comment in export} */ {bar}\n`,\n);\n\nconsole.log(importsExports);\n```\n\n## Install\n\nRequires [node](https://nodejs.org/en/) version 10 or higher:\n\n```sh\nnpm install parse-statements\n```\n\n`parse-statements` ✂️ works in any environment that supports ES2018\n(because package uses [RegExp Named Capture Groups](https://github.com/tc39/proposal-regexp-named-groups)).\n\n## API\n\n`parse-statements` ✂️ exports one runtime value — the `createParseFunction` function:\n\n```ts\nimport {createParseFunction} from 'parse-statements';\n\ntype Context = ...; // some type\n\nconst parse = createParseFunction<Context>(options);\n\nconst context: Context = ...;\n\nparse(context, 'some source code (as string)');\n```\n\nThe `options` object defines comments, statements, and a global error callback handler\n(all of these fields are optional):\n\n```ts\nimport type {Comment, OnGlobalError, Options, ParsedToken, Statement} from 'parse-statements';\n\nconst options: Options<Context> = {\n  comments, // an optional array of comments\n  onError, // an optional callback handler for global parsing errors\n  statements, // an optional array of statements\n};\n\nconst comments: readonly Comment<Context>[] = [\n  {\n    onError(\n      context: Context,\n      source: string,\n      parsedToken: {start: number; end: number; match: RegExpExecArray; token: string},\n    ) {\n      // An optional callback handler is called if, after the opening comment token,\n      // its closing token was not found.\n      // Parsing continues from the point immediately after the opening token.\n    },\n    onParse(\n      context: Context,\n      source: string,\n      openParsedToken: {start: number; end: number; match: RegExpExecArray; token: string},\n      closeParsedToken: {start: number; end: number; match: RegExpExecArray; token: string},\n    ) {\n      // An optional callback handler of comment for putting something in context.\n      // The handler is called when the parsing of the comment is completed,\n      // that is, the parsing of the close comment token is completed.\n      // The handler receives opening parsed token and closing parsed token.\n      // Parsing continues from the point immediately after the closing token.\n    },\n    // Opening and closing tokens of comment\n    // (which are converted to regexps using the `RegExp` constructor).\n    tokens: ['open raw token', 'close raw token'],\n  },\n];\n\nconst onError: OnGlobalError<Context> = (\n  context: Context,\n  source: string,\n  message: string,\n  index: number,\n) => {\n  // An optional callback handler is called when there are global parsing errors.\n};\n\nconst statements: readonly Statement<Context>[] = [\n  {\n    // If `true`, then we parse comments inside the statement (between its parts).\n    canIncludeComments: true,\n    onError(\n      context: Context,\n      source: string,\n      firstParsedToken: ParsedToken & {comments?: [ParsedToken, ParsedToken][]},\n      secondParsedToken: ParsedToken & {comments?: [ParsedToken, ParsedToken][]},\n      // ...,\n      lastParsedToken: ParsedToken,\n    ) {\n      // An optional callback handler is called if parsing the statement failed, that is,\n      // parsing started with the first statement token, but some next token was not found.\n      // The handler receives all already parsed statement tokens.\n      // If there were comments between a token and its next token, they are passed\n      // to the parsed token object as a separate `comments` property\n      // (thus, the last parsed token cannot have comments).\n      // Parsing continues from the point immediately after the last parsed token.\n    },\n    onParse(\n      context: Context,\n      source: string,\n      firstParsedToken: ParsedToken & {comments?: [ParsedToken, ParsedToken][]},\n      secondParsedToken: ParsedToken & {comments?: [ParsedToken, ParsedToken][]},\n      // ...,\n      lastParsedToken: ParsedToken,\n    ) {\n      // An optional callback handler of statement for putting something in context.\n      // The handler is called when the parsing of the statement is completed,\n      // that is, the parsing of the last statement token is completed.\n      // The handler receives all parsed statement tokens.\n      // If there were comments between a token and its next token, they are passed\n      // to the parsed token object as a separate `comments` property\n      // (thus, the last parsed token cannot have comments).\n      // Parsing continues from the point immediately after the last statement token.\n    },\n    // Not-empty array of statement raw tokens\n    // (which are converted to regexps using the `RegExp` constructor).\n    // A statement can have any positive number of tokens.\n    tokens: ['first raw token', 'second raw token'],\n    // If `true`, then the statement fisrt token is searched before the comment tokens,\n    // otherwise after. This can affect parsing because if several different tokens\n    // (first tokens of statements or opening comment tokens) are found\n    // at some position in the source, only the first one will be selected and parsed.\n    shouldSearchBeforeComments: true,\n  },\n];\n```\n\n`parse-statements` ✂️ also exports all types included in the API:\n\n```ts\nexport type {\n  /**\n   * Description of comment as the callback handlers and open and close tokens.\n   */\n  Comment,\n  /**\n   * Pair of the comment open and close tokens (raw or parsed).\n   */\n  CommentPair,\n  /**\n   * `onError` callback handler for error on comment parsing.\n   */\n  OnCommentError,\n  /**\n   * `onParse` callback handler of comment.\n   */\n  OnCommentParse,\n  /**\n   * Global `onError` callback handler for error on parsing.\n   */\n  OnGlobalError,\n  /**\n   * `onParse` callback handler of statement with concrete length (number of tokens).\n   */\n  OnParse,\n  /**\n   * Options of `createParseFunction` function.\n   */\n  Options,\n  /**\n   * Parse function.\n   */\n  Parse,\n  /**\n   * The result of parsing the token.\n   */\n  ParsedToken,\n  /**\n   * Description of statement as the callback handlers and a sequence of tokens.\n   */\n  Statement,\n};\n```\n\n## License\n\n[MIT][license-url]\n\n[conventional-commits-image]: https://img.shields.io/badge/Conventional_Commits-1.0.0-yellow.svg 'The Conventional Commits specification'\n[conventional-commits-url]: https://www.conventionalcommits.org/en/v1.0.0/\n[dependencies-none-image]: https://img.shields.io/badge/dependencies-none-success.svg 'No dependencies'\n[dependencies-none-url]: https://github.com/joomcode/parse-statements/blob/main/package.json\n[license-image]: https://img.shields.io/badge/license-MIT-blue.svg 'The MIT License'\n[license-url]: LICENSE\n[npm-image]: https://img.shields.io/npm/v/parse-statements.svg 'parse-statements'\n[npm-url]: https://www.npmjs.com/package/parse-statements\n[prettier-image]: https://img.shields.io/badge/code_style-prettier-ff69b4.svg 'Prettier code formatter'\n[prettier-url]: https://prettier.io/\n[size-image]: https://img.shields.io/bundlephobia/minzip/parse-statements 'parse-statements'\n[size-url]: https://bundlephobia.com/package/parse-statements\n",
    "licenseText": "(The MIT License)\n\nCopyright (c) 2023-2025 SIA Joom\n\nPermission is hereby granted, free of charge, to any person obtaining\na copy of this software and associated documentation files (the\n'Software'), to deal in the Software without restriction, including\nwithout limitation the rights to use, copy, modify, merge, publish,\ndistribute, sublicense, and/or sell copies of the Software, and to\npermit persons to whom the Software is furnished to do so, subject to\nthe following conditions:\n\nThe above copyright notice and this permission notice shall be\nincluded in all copies or substantial portions of the Software.\n\nTHE SOFTWARE IS PROVIDED 'AS IS', WITHOUT WARRANTY OF ANY KIND,\nEXPRESS OR IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF\nMERCHANTABILITY, FITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT.\nIN NO EVENT SHALL THE AUTHORS OR COPYRIGHT HOLDERS BE LIABLE FOR ANY\nCLAIM, DAMAGES OR OTHER LIABILITY, WHETHER IN AN ACTION OF CONTRACT,\nTORT OR OTHERWISE, ARISING FROM, OUT OF OR IN CONNECTION WITH THE\nSOFTWARE OR THE USE OR OTHER DEALINGS IN THE SOFTWARE."
  },
  "artifacts": [],
  "remote": {
    "resolved": "https://registry.npmjs.org/parse-statements/-/parse-statements-1.0.11.tgz#8787c5d383ae5746568571614be72b0689584344",
    "type": "tarball",
    "reference": "https://registry.npmjs.org/parse-statements/-/parse-statements-1.0.11.tgz",
    "hash": "8787c5d383ae5746568571614be72b0689584344",
    "integrity": "sha512-HlsyYdMBnbPQ9Jr/VgJ1YF4scnldvJpJxCVx6KgqPL4dxppsWrJHCIIxQXMJrqGnsRkNPATbeMJ8Yxu7JMsYcA==",
    "registry": "npm",
    "packageName": "parse-statements",
    "cacheIntegrity": "sha512-HlsyYdMBnbPQ9Jr/VgJ1YF4scnldvJpJxCVx6KgqPL4dxppsWrJHCIIxQXMJrqGnsRkNPATbeMJ8Yxu7JMsYcA== sha1-h4fF04OuV0ZWhXFhS+crBolYQ0Q="
  },
  "registry": "npm",
  "hash": "8787c5d383ae5746568571614be72b0689584344"
}